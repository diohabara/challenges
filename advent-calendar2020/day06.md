# Day06

結局中間試験がある間にアドベントカレンダーを書くという暴挙には出ず､結局中間試験後に記事を書くことにしました｡

まあ､クリスマス周辺は大学の授業もなく暇なので多少の遅れ(?)だったらすぐに取り戻せるでしょう｡

今回はC++の実装をするのに､自分は全くC++が分かっていないのでC++のサイトを読む(翻訳)することにします｡

[Introduction to C++11 and C++14 with Example Code Snippet](https://www.thegeekstuff.com/2016/02/c-plus-plus-11/)というサイトの翻訳をしようと思います｡このサイトはCMUのDBMSのサイトでも初学者向けにおすすめされていたので､まあ選んでも無駄になるということはないでしょう(少なくとも素人が選ぶよりはマシな選択だと思います)｡

**以下翻訳**

# C++11､C++14への入門

しばらくC++を使っていても､プログラミングの初心者でもC++11の基本的な細部を理解する必要はある

C++はC言語に基づいており､C言語は最初からUNIXと繋がっている｡C言語の作者はDennis Richieだ｡

C++はC言語に加えて､クラス､オブジェクト､テンプレート､名前空間､少数の先進的なデータ型､例外､参照､STLなどの多くのオブジェクト指向の特徴を加えた｡

C++はマルチスレッドだけでなくオブジェクト指向をサポートする汎用的な目的の言語だと認識されている｡

## 1. C++11とは？

C++に持つ問題の1つは標準を欠くということだ｡

最初の公式なC++の標準は1998年頃に始まり､それ以降､C++の標準は継続的に発展していった｡その進化が開発者と団体にとっての公式の指針となるようなある標準を持つことは必要不可欠だったのだ｡

この標準は公式にC++11と呼ばれている｡

C++14はただの少し問題点を修正し､小さな変更をした､あまり重要ではないC++11の拡張版だ｡

この標準は情報科学技術プログラミング言語C++､公式にはISO/IEC 14882:2011(C+11として広く知られる)､として登録された｡

初期には､問題の1つはベクタのベクタを使おうとしたときに `>>` を定義の左側に書こうとしたかもしれなかった｡しかし､ `> >` と書く必要がある｡その通り､意味がなく､開発者を混乱させる1つの空白を間におくのだ｡

今では､標準の適応と共に､この問題は直された｡それと似た､いくつかの小さな非論理的な文法の問題が直され､一貫するようになった｡

C++はまた､Cの以前のバージョンに互換性があるようになった｡

我々はまたテンプレートエイリアス､テンプレートとアルゴリズムへのいくつかの改善､ハッシュテーブル､タプル､配列などのいくつかの新しいテンプレートを持っている｡我々はメタプログラミングとタイプトレール､時間に関する便利品､インライン名前空間､バリアディックテンプレートを望んでいる｡

これらの改善点はそれぞれ､個別の詳細な記事で説明することができるだろう｡我々はこの記事では新しい標準のいくつかの部分を強調することにしよう｡

## 2. 範囲に基づいたループ

コンテナ(配列､スタック､リスト､ベクタなど)の中のものを走査するために､我々は典型的には以下のようなループを書く

``` cpp
for(int i=0; i<n; ++i) doSomething;
```

ループの中で､最初の部分では我々はintデータ型の変数を `i=0` で初期化している｡unsigned intもまた使うことができるだろう｡次に我々は `i<n` という条件を持っている｡最後に我々はiを `++i` で増加させている｡その変数iはそのfor文でローカルだ｡間違えて､何回か私はこのようなこと( `int i = 0` をしようとしたが､それはうまくいかなかった｡

しかし､今では使うことのできるだろう他のコンテナのためにいくつかの配列の要素を入力することができるだろうforループを持っている｡ `begin()` と `end()` だ｡

では､もし配列に要素を取り込もうとするとして､次のようななにかを使うことができるだろう｡

``` cpp
for(int& i: someDataStructure) { doSomething();}
```

もし､配列に格納された値を表示しようとするとして､配列のメンバーを守り､下で示すように `&` を省略することができるだろう｡

``` cpp
for(int i: someDataStructure) doSomething();
```

上の2つのループでは､最初は参照を使い､2つ目は値の利用を可能としている｡最初の方法はデータ構造の中での要素の変更を許し､2つ目は使っているコンテナの要素を変更することを可能にはしていない｡

## 3. 強く型付けされた列挙型

古い列挙を使う方法は欠陥があったが､いくつかの取りうる選択肢を持つだろう新しいデータの宣言方法と共に修正された｡

いくつかの例の状況は以下の通りだ｡年の月､週の曜日､我々の太陽系の惑星､もしくはもしかしたら4線の抵抗器の線だ｡

これを座標制度の場合にこれをどう使うかを確認しよう｡4つの領域があることが知られている｡第1､第2､第3､第4だ｡それは座標軸で区切られている｡

例えば､

``` cpp
enum class CoordinateArea { FirstArea, SecondArea, ThirdArea, FourthArea};

CoordinateArea caOne = CoordinateArea::FirstArea;

CoordinateArea caSome= CoordinateArea::FourthArea;
```

気づいたかもしれないが､同時に範囲解決演算子が必要になるだろう｡

## 4. ラムダ関数のラムダ式

中身を持つが､名前を書いた関数のようなものだろう｡それらは下のように宣言される｡

``` cpp
[firstPart](secondPart) TypeYouReturn{ BodyOfLambda}(actualParameters);
```

`firstPart` はラムダ関数の中で使われる変数の範囲のために使われる｡それに必要性があれば､より多くの変数を使うことができるだろう｡

[firstPart]のためにこの文法を使うとき､以下のことを覚えておくように｡

* `[]`は｢ラムダに与えるためのものは何も提供しない｣ことを意味する｡
* `[&]`は｢干渉するためのいくつかの参照を持っている｣と言うために使われる
* `[=]`はコピーを作るために使われる
* `[this]`はクラスを収めるために使われる

`secondPart` は名前無し関数のためのパラメータリストのために必要だが､同様に空のままでも構わない｡

`TypeYouReturn` はラムダからどの型が返されるかを記録するために使われる｡

`BodyOfLambda` は行われることを望む行動のために使われ､ここには､この関数の中身で適用されるように意図した行動をするように使われるコードを打つ｡

`actualParameters` はラムダ関数への入力を与えるために使われる｡

ラムダ関数の例だ｡

``` cpp
double dUpperPart = [](double dX, double dY)double{ return dX*dX +dY*dY;}
```

ラムダ関数の別の例｡

``` cpp
vector<int> iVector;
for_each( begin(iVector), end(iVector), [](int n){if(n%2==0)cout<<n<<end;});
```

## 5. 静的アサート

コードの中に､範囲外の値もしくは代わりに与えてはいけない値を入力しようとしたら､静的アサートのための良い候補だ｡

これは2つの部分を持つ｡

* 第一に､この式は評価される｡
* 第二に､その文字列リテラルは､もしテスト条件がマッチしなければメッセージとして表現される｡

これがその文法である｡

``` cpp
static_assert(evaluatedExpression, stringMessage);
```

`static_assert` の使用例だ｡

``` cpp
static_assert(sizeof(long long int)>=16;”This is unexpected”);
```

## 6. 乱数生成

これは長い間至るところにある｡乱数の生成の古い方法は新しい方法に取って代わられた｡

そのように成し遂げられたかを確かめるためにはBjorneのサイトをちょっと覗いてほしい｡乱数にどのように対処するかについて良い例がある｡

## 7. Move and &&

これに関して､我々は `lvalue` と `rvalue` を理解する必要がある｡

`lは` 左側を意味する｡ `lvalue` の持つ基本的な特性の1つは式の左側にあるようなメモリ上のオブジェクトだということだ｡例えば､ある変数など｡

`r` は右側を意味する｡これは式の右側に位置し､左側で見つかってはいけず[^1]､見本として定数がある｡

[^1]: 訳注｡"right side"と書かれていたが､間違いだと考え｢左側｣と訳した｡

より古い標準では､我々は `lvalue` のみを参照として使えたが､今では変わり､ `rvalue` も同様に参照として使うことができるだろう｡いくつかのオブジェクトをコピーするような状況有用であり､より良い解決策はムーブセマンティクスを使うことだ｡

クラスでムーブコンストラクタを適用するためには､このように呼び出すだろう｡

``` cpp
MovableClass(MovableClass&&);
```

そして､ムーブ代入が必要だとしたら､このように呼び出されるだろう｡

``` cpp
MovableClass&& operator=(MovableClass&&);
```

新しい標準では､これはよく支持され､コンテナとアルゴリズムはこのムーブセマンティクスを十分な最適化と共に使っている｡

## 8. ポインタに関するいくつかの但し書き

ポインタはC++とCの重要な概念の1つだ｡

すでに知っているように､それらはメモリ上のいくつかのオブジェクトのアドレスを格納するために使われ､そのようにコードに多くの柔軟性を持つこととなる｡

動的なデータ構造が構築され､配列の要素に高速にアクセスする方法をもつことができる｡

ポインタについて言及する価値のあることはほとんどない｡

最初は `nullptr` による `NULL` の代替だ｡これはポインタがアドレスを保持しておらず､何も指していないものを持っていることを意味する｡ゼロの値を持っている変数を持っているようなことだが､同様にいくつかの違いがある｡

次の数点はユニーク､共有､ウィークポインタなどのスマートポインタという新しい型だ｡それらが何に使われるかについて話そう｡

`unique_ptr` はメモリに格納されたいくつかのリソースの所有権を守ることを可能にするC++の新しい特徴だ｡もし､何かが所有権を持っていたら､それは共有されえないがムーブすることは可能だ｡これは別にユニークポインタに移譲できることを意味する｡

`shared_ptr` は名前から推測できるようにメモリ上で共有されるはずのいくつかのリソースの所有権を要求するような状況に最適だ｡

`weak_ptr` はメモリに存在するかもしれないものを利用することを可能にし､もしメモリを専有するオブジェクトを持っていれば利用する許可が与えられ､そのオブジェクトを削除することは可能であり､必要なデストラクタは最後に使われたら直ちに呼ばれる｡

`unique_ptr` の例は安全でないコードの例外を解決するだろう｡

ユニークポインタの文法だ｡

``` cpp
unique_ptr<someType> uniquePtr(new someType(args));
...
uniquePtr.release();
```

`shared_ptr` の場合､宣言はこのようになるだろう｡

``` cpp
shared_ptr<someType> somePtr(new someType(args));
```

ウィークポインタの文法だ｡

``` cpp
weak_ptr<someType> weakPtr= somePtr;
```

## 9. 首尾一貫な初期化と初期化リスト

もし､コンストラクタを使いたいと思ったら､古い様式の初期化 `()` を `{}` で代替することが望ましいだろう｡

コンストラクタによる古い初期化の様式はこのように実装されうるだろう｡

``` cpp
CSomeClass SomeObject( argument1, argument2);
```

上はこのように変えることができるだろう｡

``` cpp
CSomeClass SomeObject={ argument1, argument2};
```

もし､ベクタに値を入れるような状況にあるならば､数回 `push_back` を使うことが普通であるか､古い様式の波括弧を使った初期化によって成し遂げられるが､今日ではそれらは時代遅れだ｡

``` cpp
vector <int> ourVector;
for(int i=0; i<5; ourVector.push_back(i++));
```

下のようにやる方が良い｡次のように､リストの最後に要素を付け加えることができるだろうが､今では文法の観点からより一貫している｡

``` cpp
vector< int> ourVector={0,1,2,3,4,};
```

### コンストラクタの改善

もし､合計か最小値を計算するか､いくつかの条件を満たす数がいくつかあるかを数えようとしたとき､変数をいくつかの値で初期化することができるだろう｡

だから､クラスとデータ型の類似を探そうとしたら､クラスのいくつかのメンバーを0で初期化するように自分に頼むだろう｡

もし､コンパイラが新しい標準をサポートしていたら､そのようなことをするのは可能だ｡

これをする一般的な方法はこの通りだろう｡

``` cpp
class CSomeClass
{
private:
    int nSomeValue=0;
...
}
```

この方法では､もしコンストラクタを呼び出した際に､ `nSomeValue` にそれらの値を入れるだろうが､もし自分自身のコンストラクタの値を書くことを省略した場合､0がその `nSomeValue` によって予約されていた場所に初期値として格納されるはずだ｡これは役に立ち､使うことをおすすめする｡

次のことに気に入るかも知れないことは､コンストラクタを任せることだ｡それは一度1つのコンストラクタを書いたら､他のコンストラクタでも同様に再利用ができるようになるということを意味する｡

ある興味深いことは継承されたコンストラクタだ｡今､もし `CChild` クラスで必要になった場合､コンストラクタが使えるだろう｡｡

それをするために､このようなものを書くだろう｡

``` cpp
class CChild: public CParent
{
public:
using CParent::CParent
}
```

## 10. 仮想関数との挑戦

もし､仮想メソッドをよく知っていたら､ポインタがどのメソッドを利用するかを知っているはずなのでそれの仮想メソッドを持つことが重要だと知っているだろう｡

継承があり仮想メソッドを適用する必要があるとき､名前の前に `virtual` を書くだけで十分で､より下層のクラスにメソッドを持つときは毎回仮想メソッドを扱うだろう｡

同じようにいくつかの他の問題がある｡その内の1つはメソッドの行方を追うために使われる大きなテーブルがある場合それが少し遅くなってしまうかもしれないことだが､それらに多くの時間は使わずにそれらの問題のいくつかの状況と､ `override` と `final` が現時点での魔法のような解決策だと示そう｡

関数を上書きしようとしたら､親クラスで適用されたものと異なる形式のデータ型とともに動作することを望むこと意味するかもしれないだろうが､どのようにメソッドが継承クラスで動作するかを変える必要があるかもしれない｡そして､する必要があることは `override` を加えることだけになる｡メソッドにカフカをかけるのではなく､それを上書きするのだ｡

これを実践するには､ `override` を加えるだけで､望んだことが完了する｡

メソッドが上書きされるのを防ぎたい場合は､ `final` をメソッドの前に加えればどのようにメソッドが挙動しているかを変更することは不可能となる｡

## 11. C++11でのマルチスレッド

長い間､プログラムで複数のスレッドを使うためにいくつかの標準を持っていなかった｡

異なる会社がプログラマがそのようなものを必要としていることに気付いたため､そのために自身のライブラリを開発してきた｡最も有名なのはPOSIXだ｡

以下はスレッドを書くときに頭に入れておくべきことだ｡

* `std`名前空間にあるスレッドを呼び出したいならば､いくつかのヘッダを加える必要がある｡`include <thread>`と加えることが最も適切であり､もしくは他の方法で署名されているかもしれない｡
* スレッドを始める際に､`join`､`swap`､`detach`､`sleep`などを使うことができるだろう｡
* もし､結果を期待するために他のスレッドからリソースを守ろうとするならば､今ではそのライブラリに加えられた異なる種類の`mutex`を持っているべきだ｡例えば､`mutex`､`recursive_mutex`､`timed_mutex`､`recursive_timed_mutex`などだ｡

## 12. C+11様式のコード例

では､C++11の新しい様式を例証するいくつかの例を見よう｡コンパイラがこれをサポートするはずだということを頭にいれるように｡

C++11標準の最初の例だ｡

``` cpp
#include <iostream>

using namespace std;

int main(void) {
    int ourArray[5];

    for(int& i: ourArray) {
        cout << "Next element is->";
        cin >> i;
    }

    cout << "Elements  in array are!" << endl;
    for(int i: ourArray)  cout << n << endl;

    return 0;
}
```

ベクタを用いたC++標準の2つ目の例だ｡

``` cpp
#include <iostream>
#include <algorithm>
#include <vector>

using namespace std;

int main(void) {
    vector<int> nVector { 0, 5, -3, 11, -3, 7, 0, 2, 7, -6, 11, 0, 21, 12, -5};

    for_each(nVector.begin(), nVector.end(), [](int &n) {
        cout << n << " is";
        if(n==0)
            cout << " zero ";
        else if(n>0)
            cout << " positive ";
        else
            cout << " negative ";
        cout << "number\n";
    });
    return 0;
}
```

タプルのような新しいコンテナとして配列を使ったいくつかの例を試すこともできるだろう｡

タプルを使うにはこのようにすることが可能だ｡

``` cpp
auto tuple = make_tuple(“triangle”, ‘t’, 10, 15, 20);
```

1つの要素が文字列で､もう1つがベクタであるマップを宣言するにはこのようにやることができるだろう｡

``` cpp
map<string,vector<int>> aMap;
```

## 13. C++11の次のこと

C++11標準にはいくつかの小さな改善とバグ修正があり､C++14として知られている｡

少なくとも我々が望むべきことはジェネリックラムダ､ラムダキャプチャ式､関数の返り値推論､変数テンプレート､バイナリーリテラルそして､いくつかの標準ライブラリの特徴だ｡

現在C++17標準が開発中であり､2017年の終わりには公開される予定だ｡

**翻訳は以上**

MITが選ぶような文章だったのですが､原文はかなり誤字脱字がありました｡ただ､この文章を読むとC++の機能で知っておくべき機能がわかってよかったかもしれません(かもしれません)｡

## 今日のまとめ

* C++は奥が深い言語である｡
* C++(C++11)の基本的な特徴を掴んだ｡

## 次回予告

* Storageに関する部分を実装します
